//#include "ImageComponent.h"
//#include <list>
//
//#include "CameraComponent.h"
//#include "Render.h"
//
//DEF_PURE_COMPONENT(ImageComponent);
//
//void ImageComponent::size(Vector2 size) {
//	auto window = game()->window();
//	Vector3 imageSize(size.x, size.y, 1);
//	Vector3 screenSize(window->GetWidth(), window->GetHeight(), 1);
//	localScale(imageSize / screenSize);
//}
//
//Vector2 ImageComponent::size() {
//	auto window = game()->window();
//	Vector2 screenSize(window->GetWidth(), window->GetHeight());
//	return Vector2(localScale()) * screenSize;
//}
//
//void ImageComponent::OnInit() {
//	m_renderHandle = game()->render()->RegisterUIDrawer(this);
//}
//
//void ImageComponent::OnDestroy() {
//	game()->render()->UnRegisterUIDrawer(m_renderHandle);
//}
//
//void ImageComponent::OnStart() {
//	auto* shaderAsset = game()->shaderAsset();
//
//	m_material.name("Generated by ImageComponent");
//	m_material.shader = shaderAsset->GetShader(shaderAsset->GetShaderHash(shaderPath));
//
//	m_materials.push_back(&m_material);
//}
//
//void ImageComponent::SetImage(const ImageAsset::Image* image) {				
//	game()->render()->CreateTexture(image, m_material.diffuse, false, false);
//	m_InitMesh(image->width, image->height);
//}
//
//void ImageComponent::SetImage(comptr<ID3D11Texture2D> texture2D) {
//	auto* device = game()->render()->device();
//	auto& tex = m_material.diffuse;
//
//	tex.texture2D = texture2D; 
//
//	D3D11_TEXTURE2D_DESC desc = {};
//	tex.texture2D.Get()->GetDesc(&desc);
//
//	D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
//	D3D11_SHADER_RESOURCE_VIEW_DESC* pSrvDesc = nullptr;
//	
//	if (desc.Format == DXGI_FORMAT_R32_TYPELESS) {
//		srvDesc.Format = DXGI_FORMAT_R32_FLOAT; // DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
//		srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
//		srvDesc.Texture2D.MipLevels = 1;
//		srvDesc.Texture2D.MostDetailedMip = 0;
//
//		pSrvDesc = &srvDesc;
//	}
//	
//	auto hres = device->CreateShaderResourceView(tex.texture2D.Get(), pSrvDesc, tex.srv.GetAddressOf());
//	assert(SUCCEEDED(hres));
//
//	m_InitMesh(desc.Width, desc.Height);
//}
//
//void ImageComponent::m_InitMesh(int width, int height) {
//	std::vector<Mesh4::Vertex> verteces;
//	std::vector<int> indeces;
//	m_GenerateForm(&verteces, &indeces);
//	m_mesh.AddShape(&verteces, &indeces, game()->render(), 0);
//
//	size(Vector2(width, height));
//}
//
//void ImageComponent::m_GenerateForm(std::vector<Mesh4::Vertex>* verteces, std::vector<int>* indeces) {
//	verteces->insert(verteces->begin(), 4, Mesh4::Vertex());
//	indeces->insert(indeces->begin(), { 0,3,2, 2,1,0 });
//
//	verteces->at(0).uv = { 0,0,0,0 };
//	verteces->at(1).uv = { 0,1,0,0 };
//	verteces->at(2).uv = { 1,1,0,0 };
//	verteces->at(3).uv = { 1,0,0,0 };
//
//	verteces->at(0).position = verteces->at(0).uv * 2;
//	verteces->at(1).position = verteces->at(1).uv * 2;
//	verteces->at(2).position = verteces->at(2).uv * 2;
//	verteces->at(3).position = verteces->at(3).uv * 2;
//}
//
//void ImageComponent::OnDrawUI() {
//	if (!m_visible)
//		return;
//
//	auto window = game()->window();
//	Vector3 screenSize(window->GetWidth(), window->GetHeight(), 1);
//
//	auto camera = game()->render()->camera();
//	auto cameraPosition = camera->worldPosition();
//	auto worldMatrix = GetWorldMatrix();
//
//	worldMatrix.Translation((worldMatrix.Translation() / screenSize) * 2 - Vector3(1, 1, 0));
//
//	auto transMatrix = worldMatrix * Matrix::Identity;
//
//	Mesh4::DynamicData data;
//	data.render = game()->render();
//	data.materials = &m_materials;
//	data.worldMatrix = &worldMatrix;
//	data.transfMatrix = &transMatrix;
//	data.directionLight = game()->lighting()->directionLight();
//	data.cameraPosition = &cameraPosition;
//
//	m_mesh.Draw(data);
//}
//
