#include "MeshComponent.h"
#include <list>

#include <SimpleMath.h>

#include "Game.h"
#include "Render.h"
#include "Assets.h"
#include "AssetStore.h"
#include "RenderPass.h"
#include "MeshAsset.h"
#include "MaterialAsset.h"
#include "Actor.h"
#include "Random.h"
#include "Vertex.h"

#include "CameraComponent.h"
#include "LineComponent.h"

using namespace DirectX::SimpleMath;


bool MeshComponent::mono_inited = false;
mono::mono_method_invoker<void(CsRef, CppRef)> MeshComponent::mono_SetFromCpp;

void MeshComponent::m_InitMono() {
	if (mono_inited)
		return;

	auto type = game()->mono()->GetType("Engine", "MeshComponent");
	mono_SetFromCpp = mono::make_method_invoker<void(CsRef, CppRef)>(type, "cpp_SetFromCpp");

	mono_inited = true;
}

void MeshComponent::OnPreInit() {
	m_render = game()->render();
	m_InitMono();

	if (m_preinitMesh != nullptr) {
		mesh(m_preinitMesh);
		m_preinitMesh = nullptr;
	}
	if (m_preinitMaterials.size() > 0) {
		for (int i = 0; i < m_preinitMaterials.size() || i < m_materials.size(); i++)
			SetMaterial(i, m_preinitMaterials[i]);
		m_preinitMaterials.clear();
	}
}

void MeshComponent::MeshComponent::OnInit() {
	OnPreInit();

	if (m_castShadow)
		m_shadowCaster = scene()->renderer.AddShadowCaster(this);
}

void MeshComponent::OnDestroy() { 
	m_preinitMesh = m_mesh;
	m_preinitMaterials = m_materials;

	m_DeleteResources();

	if (m_castShadow)
		scene()->renderer.RemoveShadowCaster(m_shadowCaster);
}

void MeshComponent::m_InitDynamic() {
	if (IsDynamic())
		return;

	auto* store = game()->assetStore();
	auto* assets = game()->assets();

	auto assetId = store->CreateRuntimeAssetId("DynamicMesh");
	auto* newMesh = new MeshAsset();

	assets->Push(assetId, newMesh);

	if (m_mesh != nullptr)
		newMesh->resource = m_mesh->resource;
			
	m_SetMesh(newMesh, true);
}

void MeshComponent::RemoveMaterial(size_t index) {
	auto assets = game()->assets();

	if (index > m_mesh->resource.maxMaterialIndex())
		return;

	// Удаляем старый материал
	m_UnRegisterShapesWithMaterial(index);
	m_DeleteLocalDynamicMaterial(index);

	// Ставим стандартный материал
	auto defaultMaterial = assets->GetStatic<MaterialAsset>(Assets::DefaultMaterial);
	m_materials[index] = defaultMaterial;
	m_RegisterShapesWithMaterial(index);
}

void MeshComponent::RemoveMaterials() {
	m_DeleteMaterials();

	if (m_mesh != nullptr)
		m_FillByDefaultMaterial(m_mesh->resource.maxMaterialIndex() + 1);
}

void MeshComponent::ClearMesh() {
	m_DeleteResources();

	if (m_mesh != nullptr)
		m_FillByDefaultMaterial(m_mesh->resource.maxMaterialIndex() + 1);
}

void MeshComponent::m_DeleteResources() {
	m_DeleteMaterials();
	if (IsDynamic()) {
		game()->assets()->Pop(m_dynamicMesh->assetIdHash());
		delete m_dynamicMesh;
		m_dynamicMesh = nullptr;
		m_mesh = nullptr;
	}
}

void MeshComponent::m_DeleteMaterials() {
	for (int i = 0; i < m_materials.size(); ++i) {
		m_UnRegisterShapesWithMaterial(i);
		m_DeleteLocalDynamicMaterial(i);
	}

	m_materials.clear();
	m_dynamicMaterials.clear();
	m_shapeIters.clear();
}

void MeshComponent::m_DeleteLocalDynamicMaterial(int index) {
	auto localMaterial = m_dynamicMaterials[index];
	if (localMaterial == nullptr)
		return;

	MaterialAsset::DeleteDinamic(game(), localMaterial);

	m_materials[index] = nullptr;
	m_dynamicMaterials[index] = nullptr;
}

void MeshComponent::AddShape(
	std::vector<Vertex>* verteces,
	std::vector<int>* indeces,
	size_t materialIndex)
{
	m_InitDynamic();

	m_dynamicMesh->resource.AddShape(verteces, indeces, m_render, materialIndex);

	m_FillByDefaultMaterial(m_dynamicMesh->resource.maxMaterialIndex() + 1);
}

void MeshComponent::AddShape(
	Vertex* verteces,
	int vertecesLength,
	int* indeces,
	int indecesLength,
	int materialIndex) 
{
	m_InitDynamic();

	m_dynamicMesh->resource.AddShape(verteces, vertecesLength, indeces, indecesLength, m_render, materialIndex);

	m_FillByDefaultMaterial(m_dynamicMesh->resource.maxMaterialIndex() + 1);
}

void MeshComponent::SetMaterial(size_t index, const fs::path& shaderPath) {
	m_InitDynamic();

	if (index > m_mesh->resource.maxMaterialIndex())
		return;

	assert(index < m_dynamicMaterials.size());

	// Удаляем локальный материал
	m_UnRegisterShapesWithMaterial(index);
	m_DeleteLocalDynamicMaterial(index);

	// Создаем навый материал
	auto material = MaterialAsset::CreateDynamic(game(), "Generated by MeshComponent", shaderPath);

	// Запоминаем навый материал
	m_materials[index] = material;
	m_dynamicMaterials[index] = material;
	m_RegisterShapesWithMaterial(index);
}

void MeshComponent::SetMaterial(size_t index, const MaterialAsset* material) {
	if (index > m_mesh->resource.maxMaterialIndex())
		return;

	assert(index < m_dynamicMaterials.size());

	// Удаляем локальный материал
	m_UnRegisterShapesWithMaterial(index);
	m_DeleteLocalDynamicMaterial(index);

	// Запоминаем навый материал
	m_materials[index] = material;
	m_dynamicMaterials[index] = nullptr;
	m_RegisterShapesWithMaterial(index);
}

const MaterialAsset* MeshComponent::GetMaterial(size_t index) {
	if (index >= m_materials.size())
		return nullptr;

	return m_materials[index];
}

void MeshComponent::m_FillByDefaultMaterial(int targetSize) {
	auto assets = game()->assets();

	if (m_materials.size() < targetSize) {
		auto defaultMaterial = assets->GetStatic<MaterialAsset>(Assets::DefaultMaterial);

		m_shapeIters.resize(m_mesh->resource.shapeCount() > 0 ? m_mesh->resource.shapeCount() : 1);

		for (int matIndex = m_materials.size(); matIndex < targetSize; matIndex++) {

			m_materials.push_back(defaultMaterial);
			m_dynamicMaterials.push_back(nullptr);

			m_RegisterShapesWithMaterial(matIndex);
		}
	}
}

void MeshComponent::m_SetMesh(const MeshAsset* mesh, bool isDynamic) {
	m_DeleteResources();
	m_mesh = mesh;
	m_meshVersion = m_mesh != nullptr ? m_mesh->resource.version : 0;
	m_SetMaterialsFromMesh();

	if(isDynamic)
		m_dynamicMesh = (MeshAsset*)mesh;

	if (csRef() > 0) {
		auto newRef = m_mesh != nullptr ? CppRefs::GetRef((void*)m_mesh) : RefCpp(0);
		mono_SetFromCpp(csRef(), newRef);
	}
}

void MeshComponent::SetMeshFromCs(const MeshAsset* mesh) {
	m_DeleteResources();
	m_mesh = mesh;
	m_SetMaterialsFromMesh();
}

void MeshComponent::m_SetMaterialsFromMesh() {
	if (m_mesh == nullptr)
		return;

	// Берем статик материалы меша
	auto* staticMaterials = m_mesh->GetMaterials();
	auto newSize = staticMaterials->size();

	// Создаем массивы для материалов
	m_materials.reserve(newSize);
	m_dynamicMaterials.reserve(newSize);

	// Создаем массив итераторов shape-ов
	m_shapeIters.resize(m_mesh->resource.shapeCount());
		
	for (int materialIndex = 0; materialIndex < newSize; materialIndex++) {
		auto material = staticMaterials->at(materialIndex);

		// Запоминаем статик материалы 
		m_materials.push_back(material);
		m_dynamicMaterials.push_back(nullptr);
		m_RegisterShapesWithMaterial(materialIndex);
	}

	// Если новых материалов меньше, чем используется,
	// Заполняем стандартными материалами.
	m_FillByDefaultMaterial(m_mesh->resource.maxMaterialIndex() + 1);
}

void MeshComponent::m_OnMeshReload() {
	std::cout << "MeshComponent::m_OnMeshReload() NotImplemented" << std::endl;
	m_meshVersion = m_mesh->resource.version;
}

void MeshComponent::m_RegisterShapesWithMaterial(int materialIndex) {
	auto* material = m_materials[materialIndex];
	assert(material != nullptr);

	bool isNewDynamic = 
		m_mesh->resource.shapeCount() == 0 &&
		m_materials.size() == 1 && 
		materialIndex == 0;

	if (isNewDynamic) {
		m_shapeIters[0] = scene()->renderer.RegisterShape(&material->resource, this, 0);
		return;
	}

	for (int shapeIndex = 0; shapeIndex < m_mesh->resource.shapeCount(); shapeIndex++) {
		const auto* shape = &m_mesh->resource.m_shapes[shapeIndex];

		if (shape->materialIndex == materialIndex)
			m_shapeIters[shapeIndex] = scene()->renderer.RegisterShape(&material->resource, this, shapeIndex);
	}
}

void MeshComponent::m_UnRegisterShapesWithMaterial(int materialIndex) {
	auto* material = m_materials[materialIndex];
	if (material == nullptr)
		return;

	if (!CppRefs::IsValidPointer(material)) {
		std::string msg = ""; 
		msg += "Perhaps a dynamic material was deleted but not removed from a MeshComponent.";
		msg += " Add a call to MeshComponent.RemoveMaterial() before deleting a dynamic material.";
		throw std::exception(msg.c_str());
	}

	for (int shapeIndex = 0; shapeIndex < m_mesh->resource.m_shapes.size(); shapeIndex++) {
		const auto* shape = &m_mesh->resource.m_shapes[shapeIndex];

		if (shape->materialIndex == materialIndex) 
			scene()->renderer.UnRegisterShape(&material->resource, m_shapeIters[shapeIndex]);
	}
}

void MeshComponent::castShadow(bool value) {
	if (m_castShadow && !value)
		scene()->renderer.RemoveShadowCaster(m_shadowCaster);

	if (!m_castShadow && value)
		m_shadowCaster = scene()->renderer.AddShadowCaster(this);

	m_castShadow = value;
}

void MeshComponent::OnDrawShadow(RenderPass* renderPass, const Vector3& scale) {
	if (!isDebug && IsActivated())
		m_Draw(renderPass, scale);
}

void MeshComponent::OnDraw() {
	//if (!isDebug)
		m_Draw();
}

//void MeshComponent::OnDrawDebug() {
//	if (isDebug)
//		m_Draw();
//}

void MeshComponent::m_Draw(RenderPass* renderPass, const Vector3& scale) {
	if (!visible || m_mesh == nullptr || !IsActivated())
		return;

	if (m_meshVersion != m_mesh->resource.version)
		m_OnMeshReload();

	auto camera = m_render->renderer()->camera();
	auto cameraPosition = camera->worldPosition();
	auto scaleMatrix = Matrix::CreateScale(meshScale * scale);
	auto offsetMatrix = Matrix::CreateTranslation(meshOffset);

	auto worldMatrix = GetWorldMatrix();
		 worldMatrix = scaleMatrix * offsetMatrix * worldMatrix;

	auto transMatrix = worldMatrix * camera->cameraMatrix();

	MeshShaderData params;
	params.render = m_render;
	params.worldMatrix = &worldMatrix;
	params.transfMatrix = &transMatrix;
	params.cameraPosition = &cameraPosition;

	for (int i = 0; i < m_mesh->resource.shapeCount(); i++){
		if (renderPass != nullptr) {
			auto material = m_materials[m_mesh->resource.m_shapes[i].materialIndex];
			renderPass->PrepareMaterial(&material->resource);
		}
		m_mesh->resource.DrawShape(params, i);
	}

	///TODO: 
	/// boundMesh.verteces * transMatrix 
	/// и передать в navmesh 
}

void MeshComponent::OnDrawShape(int index) {
	if (!visible || m_mesh == nullptr || !IsActivated())
		return;

	if (m_meshVersion != m_mesh->resource.version)
		m_OnMeshReload();

	auto id = actor()->Id();

	auto camera = m_render->renderer()->camera();
	auto cameraPosition = camera->worldPosition();
	auto scaleMatrix = Matrix::CreateScale(meshScale);
	auto offsetMatrix = Matrix::CreateTranslation(meshOffset);

	auto worldMatrix = GetWorldMatrix();
		 worldMatrix = scaleMatrix * offsetMatrix * worldMatrix;

	auto transMatrix = worldMatrix * camera->cameraMatrix();

	MeshShaderData params;
	params.render = m_render;
	params.worldMatrix = &worldMatrix;
	params.transfMatrix = &transMatrix;
	params.cameraPosition = &cameraPosition;

	m_mesh->resource.DrawShape(params, index);
}


DEF_COMPONENT(MeshComponent, Engine.MeshComponent, 3, RunMode::EditPlay) {
	OFFSET(0, MeshComponent, isDebug);
	OFFSET(1, MeshComponent, visible);
	OFFSET(2, MeshComponent, meshScale);
}

DEF_PROP_GET(MeshComponent, bool, IsDynamic);
DEF_PROP_GET(MeshComponent, bool, IsStatic);
DEF_PROP_GET(MeshComponent, int, MaterialCount);
DEF_PROP_GETSET(MeshComponent, bool, castShadow);

DEF_FUNC(MeshComponent, SetFromCs, void)(CppRef compRef, CppRef meshRef) {
	auto component = CppRefs::ThrowPointer<MeshComponent>(compRef);
	auto mesh = CppRefs::ThrowPointer<MeshAsset>(meshRef);

	component->SetMeshFromCs(mesh);
}

DEF_FUNC(MeshComponent, AddShape, void)( 
	CppRef compRef,
	Vertex* verteces, 
	int vlength, 
	int* indeces, 
	int ilength, 
	int matIndex) 
{
	auto component = CppRefs::ThrowPointer<MeshComponent>(compRef);
	component->AddShape(verteces, vlength, indeces, ilength, matIndex);
}

DEF_FUNC(MeshComponent, RemoveMaterials, void)(CppRef compRef) {
	CppRefs::ThrowPointer<MeshComponent>(compRef)->RemoveMaterials();
}

DEF_FUNC(MeshComponent, RemoveMaterial, void)(CppRef compRef, int index) {
	CppRefs::ThrowPointer<MeshComponent>(compRef)->RemoveMaterial(index);
}

DEF_FUNC(MeshComponent, ClearMesh, void)(CppRef compRef) {
	CppRefs::ThrowPointer<MeshComponent>(compRef)->ClearMesh();
}

DEF_FUNC(MeshComponent, SetMaterial, void)(CppRef compRef, size_t index, CppRef materialRef) {
	auto material = CppRefs::ThrowPointer<MaterialAsset>(materialRef);
	auto meshComp = CppRefs::ThrowPointer<MeshComponent>(compRef);
	
	meshComp->SetMaterial(index, material);
}

DEF_FUNC(MeshComponent, GetMaterial, CppRef)(CppRef compRef, size_t index) {
	auto material = CppRefs::ThrowPointer<MeshComponent>(compRef)->GetMaterial(index);
	return material != nullptr ? CppRefs::GetRef((void*)material) : RefCpp(0);
}

DEF_FUNC(MeshComponent, SetPreInitMesh, void)(CppRef compRef, CppRef meshRef) {
	auto meshComp = CppRefs::ThrowPointer<MeshComponent>(compRef);
	auto mesh = CppRefs::ThrowPointer<MeshAsset>(meshRef);

	meshComp->m_preinitMesh = mesh;
}

DEF_FUNC(MeshComponent, SetPreInitMaterials, void)(CppRef compRef, size_t* matRefs, int count) {
	auto* meshComp = CppRefs::ThrowPointer<MeshComponent>(compRef);

	meshComp->m_preinitMaterials.clear();

	auto ptr = matRefs;
	for (int i = 0; i < count; i++, ptr++) {
		auto cppRef = RefCpp(*ptr);
		auto* material = CppRefs::ThrowPointer<MaterialAsset>(cppRef);

		meshComp->m_preinitMaterials.push_back(material);
	}
}

DEF_FUNC(MeshComponent, OnPreInit, void)(CppRef compRef) {
	CppRefs::ThrowPointer<MeshComponent>(compRef)->OnPreInit();
}